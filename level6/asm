Dump of assembler code for function n:
   # Usual setup
   0x08048454 <+0>:     push   %ebp
   0x08048455 <+1>:     mov    %esp,%ebp

   # Allocating 24 bytes on the stack
   0x08048457 <+3>:     sub    $0x18,%esp

   # Moving "/bin/cat /home/user/level7/.pass" (the string at the 0x80485b0 address) into esp to be used as the argument of system 
   0x0804845a <+6>:     movl   $0x80485b0,(%esp)
   # To recap: system("/bin/cat /home/user/level7/.pass")
   0x08048461 <+13>:    call   0x8048370 <system@plt>

   # Leaving the function
   0x08048466 <+18>:    leave  
   0x08048467 <+19>:    ret    

Dump of assembler code for function m:
   # Usual setup
   0x08048468 <+0>:     push   %ebp
   0x08048469 <+1>:     mov    %esp,%ebp

   # Allocating 24 bytes on the stack
   0x0804846b <+3>:     sub    $0x18,%esp

   # Moving "Nope" (the string at the 0x80485d1 address) into esp to be used as the argument of system 
   0x0804846e <+6>:     movl   $0x80485d1,(%esp)
   # To recap: puts("Nope")
   0x08048475 <+13>:    call   0x8048360 <puts@plt>

   # Leaving the function
   0x0804847a <+18>:    leave  
   0x0804847b <+19>:    ret    

Dump of assembler code for function main:
   # Usual setup
   0x0804847c <+0>:     push   %ebp
   0x0804847d <+1>:     mov    %esp,%ebp
   0x0804847f <+3>:     and    $0xfffffff0,%esp

   # Allocating 32 bytes on the stack
   0x08048482 <+6>:     sub    $0x20,%esp

   # Moving 64 into esp to be used as the argument of malloc
   0x08048485 <+9>:     movl   $0x40,(%esp)
   # To recap: malloc(64)
   0x0804848c <+16>:    call   0x8048350 <malloc@plt>
   # Moving the return of malloc(64) into esp + 28, since we allocated 32 bytes for the stack our buffer will therefore be 4 bytes such as char *buffer
   0x08048491 <+21>:    mov    %eax,0x1c(%esp)

   # Moving 4 into esp to be used as the argument of malloc
   0x08048495 <+25>:    movl   $0x4,(%esp)
   # To recap: malloc(4)
   0x0804849c <+32>:    call   0x8048350 <malloc@plt>
   # Moving the return of malloc(64) into esp + 24, since we allocated 32 bytes for the stack and that the next variable starts at esp + 28 our buffer will therefore be 4 bytes such as void (**func)(void) (it needs to be a function pointer for the following ASM code to happen)
   0x080484a1 <+37>:    mov    %eax,0x18(%esp)
   # Moving the address of the function m into edx
   0x080484a5 <+41>:    mov    $0x8048468,%edx
   # Moving *func into eax
   0x080484aa <+46>:    mov    0x18(%esp),%eax
   # Moving the address of the function m into eax, we're essentially doing *func = m;
   0x080484ae <+50>:    mov    %edx,(%eax)
   # Moving *argv[0] into eax 
   0x080484b0 <+52>:    mov    0xc(%ebp),%eax
   # Go to *argv[1] (*argv[0] + 4 bytes = *argv[1])
   0x080484b3 <+55>:    add    $0x4,%eax
   # Dereference the address to get the value (*argv[1] => argv[1])
   0x080484b6 <+58>:    mov    (%eax),%eax
   # Moving argv[1] into edx
   0x080484b8 <+60>:    mov    %eax,%edx
   # Moving buffer into eax

   0x080484ba <+62>:    mov    0x1c(%esp),%eax
   # Moving argv[1] into esp to be used as the second argument of strcpy
   0x080484be <+66>:    mov    %edx,0x4(%esp)
   # Moving buffer into esp to be used as the first argument of strcpy
   0x080484c2 <+70>:    mov    %eax,(%esp)
   # To recap: strcpy(buffer, argv[1])
   0x080484c5 <+73>:    call   0x8048340 <strcpy@plt>
   # Moving *func into eax
   0x080484ca <+78>:    mov    0x18(%esp),%eax
   # Dereference eax (since func is a pointer to the address of the m function)
   0x080484ce <+82>:    mov    (%eax),%eax
   # Call address of function m (func())
   0x080484d0 <+84>:    call   *%eax

   # Leaving the function
   0x080484d2 <+86>:    leave  
   0x080484d3 <+87>:    ret    