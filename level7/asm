Dump of assembler code for function m:
   # Usual setup
   0x080484f4 <+0>:     push   %ebp
   0x080484f5 <+1>:     mov    %esp,%ebp

   # Allocating 24 bytes on the stack
   0x080484f7 <+3>:     sub    $0x18,%esp

   # Moving 0 into esp to be used as the argument of time 
   0x080484fa <+6>:     movl   $0x0,(%esp)
   # To recap: time(0)
   0x08048501 <+13>:    call   0x80483d0 <time@plt>
   # Moving "%s - %d\n" (the string at the 0x80486e0 address) into edx 
   0x08048506 <+18>:    mov    $0x80486e0,%edx
   # Moving the return of time (seconds) into esp to be used as the third argument of printf
   0x0804850b <+23>:    mov    %eax,0x8(%esp)
   # Moving c (an empty string of 80 bytes at the 0x8049960 address) into esp to be used as the second argument of printf
   0x0804850f <+27>:    movl   $0x8049960,0x4(%esp)
   # Moving "%s - %d\n" into esp to be used as the first argument of printf
   0x08048517 <+35>:    mov    %edx,(%esp)
   # printf("%s - %d\n", c, seconds)
   0x0804851a <+38>:    call   0x80483b0 <printf@plt>

   # Leaving the function
   0x0804851f <+43>:    leave  
   0x08048520 <+44>:    ret    

Dump of assembler code for function main:
   # Usual setup
   0x08048521 <+0>:     push   %ebp
   0x08048522 <+1>:     mov    %esp,%ebp
   0x08048524 <+3>:     and    $0xfffffff0,%esp

   # Allocating 32 bytes on the stack
   0x08048527 <+6>:     sub    $0x20,%esp

   # Moving 8 into esp to be used as the argument of malloc
   0x0804852a <+9>:     movl   $0x8,(%esp)
   # To recap: malloc(8)
   0x08048531 <+16>:    call   0x80483f0 <malloc@plt>
   # Moving the return of malloc(8) into esp + 28, since we allocated 32 bytes for the stack our buffer will therefore be 4 bytes such as char *buffer
   0x08048536 <+21>:    mov    %eax,0x1c(%esp)
   # Moving buffer into eax
   0x0804853a <+25>:    mov    0x1c(%esp),%eax
   # Moving 1 into buffer, essentially doing *buffer = 1
   0x0804853e <+29>:    movl   $0x1,(%eax)
   # Moving 8 into esp to be used as the argument of malloc  
   0x08048544 <+35>:    movl   $0x8,(%esp)
   # To recap: malloc(8)
   0x0804854b <+42>:    call   0x80483f0 <malloc@plt>
   # Moving the return of malloc(8) into edx
   0x08048550 <+47>:    mov    %eax,%edx
   # Moving buffer into eax 
   0x08048552 <+49>:    mov    0x1c(%esp),%eax
   # Moving the return of malloc(8) into eax + 4 essentially doing buffer[1] = malloc(8)
   0x08048556 <+53>:    mov    %edx,0x4(%eax)
   # Moving 8 into esp to be used as the argument of malloc
   0x08048559 <+56>:    movl   $0x8,(%esp)
   # To recap: malloc(8)
   0x08048560 <+63>:    call   0x80483f0 <malloc@plt>
   # Moving the return of malloc(8) into esp + 24, since we allocated 32 bytes for the stack and that the next variable is at esp + 28 our buffer will therefore be 4 bytes such as char *buffer2
   0x08048565 <+68>:    mov    %eax,0x18(%esp)
   # Moving buffer2 into eax
   0x08048569 <+72>:    mov    0x18(%esp),%eax
   # Moving 2 into buffer2, essentially doing *buffer2 = 2
   0x0804856d <+76>:    movl   $0x2,(%eax)
   # Moving 8 into esp to be used as the argument of malloc
   0x08048573 <+82>:    movl   $0x8,(%esp)
   # To recap: malloc(8)
   0x0804857a <+89>:    call   0x80483f0 <malloc@plt>
   # Moving the return of malloc(8) into edx
   0x0804857f <+94>:    mov    %eax,%edx
   # Moving buffer2 into eax
   0x08048581 <+96>:    mov    0x18(%esp),%eax
   # Moving the return of malloc(8) into eax + 4 essentially doing buffer2[2] = malloc(8)
   0x08048585 <+100>:   mov    %edx,0x4(%eax)
   # Moving *argv[0] into eax
   0x08048588 <+103>:   mov    0xc(%ebp),%eax
   # Go to *argv[1] (*argv[0] + 4 bytes = *argv[1])
   0x0804858b <+106>:   add    $0x4,%eax
   # Dereference the address to get the value (*argv[1] => argv[1])
   0x0804858e <+109>:   mov    (%eax),%eax
   # Moving argv[1] into edx
   0x08048590 <+111>:   mov    %eax,%edx
   # Moving buffer into eax
   0x08048592 <+113>:   mov    0x1c(%esp),%eax
   # Moving buffer[1] into eax
   0x08048596 <+117>:   mov    0x4(%eax),%eax
   # Moving argv[1] into esp to be used as the second argument of strcpy
   0x08048599 <+120>:   mov    %edx,0x4(%esp)
   # Moving buffer[1] into esp to be used as the first argument of strcpy
   0x0804859d <+124>:   mov    %eax,(%esp)
   # To recap: strcpy(buffer[1], argv[1])
   0x080485a0 <+127>:   call   0x80483e0 <strcpy@plt>
   # Moving *argv[0] into eax
   0x080485a5 <+132>:   mov    0xc(%ebp),%eax
   # Go to *argv[2] (*argv[0] + 8 bytes = *argv[2])
   0x080485a8 <+135>:   add    $0x8,%eax
   # Dereference the address to get the value (*argv[2] => argv[2])
   0x080485ab <+138>:   mov    (%eax),%eax
   # Moving argv[2] into edx
   0x080485ad <+140>:   mov    %eax,%edx
   # Moving buffer2 into eax
   0x080485af <+142>:   mov    0x18(%esp),%eax
   # Moving buffer2[1] into eax
   0x080485b3 <+146>:   mov    0x4(%eax),%eax
   # Moving argv[2] into esp to be used as the second argument of strcpy
   0x080485b6 <+149>:   mov    %edx,0x4(%esp)
   # Moving buffer2[1] into esp to be used as the first argument of strcpy
   0x080485ba <+153>:   mov    %eax,(%esp)
   # To recap: strcpy(buffer2[1], argv[2])
   0x080485bd <+156>:   call   0x80483e0 <strcpy@plt>
   # Moving "r" (the string at the 0x80486e9 address) into edx
   0x080485c2 <+161>:   mov    $0x80486e9,%edx
   # Moving "/home/user/level8/.pass" (the string at the 0x80486eb address) into eax
   0x080485c7 <+166>:   mov    $0x80486eb,%eax
   # Moving "/home/user/level8/.pass" into esp to be used as the second argument of fopen
   0x080485cc <+171>:   mov    %edx,0x4(%esp)
   # Moving "r" into esp to be used as the first argument of fopen
   0x080485d0 <+175>:   mov    %eax,(%esp)
   # To recap: fopen("r", "/home/user/level8/.pass")
   0x080485d3 <+178>:   call   0x8048430 <fopen@plt>
   # Moving the return of fopen("r", "/home/user/level8/.pass") into esp to be used as the third argument of fgets
   0x080485d8 <+183>:   mov    %eax,0x8(%esp)
   # Moving 68 into esp to be used as the second argument of fgets
   0x080485dc <+187>:   movl   $0x44,0x4(%esp)
   # Moving c (an empty string of 80 bytes at the 0x8049960 address) into esp to be used as the first argument of fgets
   0x080485e4 <+195>:   movl   $0x8049960,(%esp)
   # fgets(c, 68, fopen("/home/user/level8/.pass"))
   0x080485eb <+202>:   call   0x80483c0 <fgets@plt>
   # Moving "~~" (the string at the 0x8048703 address) into esp to be used as the argument of puts
   0x080485f0 <+207>:   movl   $0x8048703,(%esp)
   # To recap: puts("~~")
   0x080485f7 <+214>:   call   0x8048400 <puts@plt> 

   # Moving 0 into eax to do a return 0
   0x080485fc <+219>:   mov    $0x0,%eax
   # Leaving the function
   0x08048601 <+224>:   leave  
   0x08048602 <+225>:   ret    