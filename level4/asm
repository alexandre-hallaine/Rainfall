  Dump of assembler code for function p:
   # Usual setup
   0x08048444 <+0>:     push   %ebp
   0x08048445 <+1>:     mov    %esp,%ebp

   # Allocating 24 bytes on the stack
   0x08048447 <+3>:     sub    $0x18,%esp

   # Moving the argument of the p function (our buffer) into eax
   0x0804844a <+6>:     mov    0x8(%ebp),%eax
   # Moving buffer into esp to be used as the argument of printf
   0x0804844d <+9>:     mov    %eax,(%esp)
   # To recap: printf(buffer)
   0x08048450 <+12>:    call   0x8048340 <printf@plt>

   # Leaving the function
   0x08048455 <+17>:    leave  
   0x08048456 <+18>:    ret 
   
Dump of assembler code for function n:
   # Usual setup
   0x08048457 <+0>:     push   %ebp
   0x08048458 <+1>:     mov    %esp,%ebp

   # Allocating 536 bytes on the stack
   0x0804845a <+3>:     sub    $0x218,%esp

   # Moving stdin into eax
   0x08048460 <+9>:     mov    0x8049804,%eax
   # Moving stdin into esp to be used as the third argument of fgets
   0x08048465 <+14>:    mov    %eax,0x8(%esp)
   # Moving 512 into esp to be used as the second argument of fgets
   0x08048469 <+18>:    movl   $0x200,0x4(%esp)
   # Calculate the address of ebp - 520, this will be our buffer for fgets, since we allocated 536 bytes for the stack our buffer will therefore be 512 bytes such as char buffer[512], and putting it into eax
   0x08048471 <+26>:    lea    -0x208(%ebp),%eax
   # Moving the address of buffer into esp to be used as the first argument of fgets
   0x08048477 <+32>:    mov    %eax,(%esp)
   # To recap: fgets(buffer, 512, stdin)
   0x0804847a <+35>:    call   0x8048350 <fgets@plt>
   # Calculate the address of buffer and putting it into eax
   0x0804847f <+40>:    lea    -0x208(%ebp),%eax
   # Moving the address of buffer into esp to be used as the argument of p
   0x08048485 <+46>:    mov    %eax,(%esp)
   # To recap: p(buffer)
   0x08048488 <+49>:    call   0x8048444 <p>
   # Moving a global variable m that has not been initialized (0x8049810 <m>:  0) into eax
   0x0804848d <+54>:    mov    0x8049810,%eax
   # Compare the m variable with 16930116
   0x08048492 <+59>:    cmp    $0x1025544,%eax
   # if not equal jump to n+78
   0x08048497 <+64>:    jne    0x80484a5 <n+78>

   # Moving "/bin/cat /home/user/level5/.pass" (the string at the 0x8048590 address) into esp to be used as the argument of system
   0x08048499 <+66>:    movl   $0x8048590,(%esp)
   # To recap: system("/bin/cat /home/user/level5/.pass")
   0x080484a0 <+73>:    call   0x8048360 <system@plt>

   # Leaving the function
   0x080484a5 <+78>:    leave  
   0x080484a6 <+79>:    ret  

Dump of assembler code for function main:
   # Usual setup
   0x080484a7 <+0>:     push   %ebp
   0x080484a8 <+1>:     mov    %esp,%ebp
   0x080484aa <+3>:     and    $0xfffffff0,%esp

   # To recap: n()
   0x080484ad <+6>:     call   0x8048457 <n>

   # Leaving the function
   0x080484b2 <+11>:    leave  
   0x080484b3 <+12>:    ret    