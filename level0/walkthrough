# Level0

## Hint

Use **gdb** to find the exploit !

## Answer

Let's see what we have here:
```
level0@RainFall:~$ ll
total 737
dr-xr-x---+ 1 level0 level0     60 Mar  6  2016 ./
dr-x--x--x  1 root   root      340 Sep 23  2015 ../
-rw-r--r--  1 level0 level0    220 Apr  3  2012 .bash_logout
-rw-r--r--  1 level0 level0   3530 Sep 23  2015 .bashrc
-rwsr-x---+ 1 level1 users  747441 Mar  6  2016 level0*
-rw-r--r--  1 level0 level0    675 Apr  3  2012 .profile
```

When we run _level0_ the binary, we get the following:
```
level0@RainFall:~$ ./level0
Segmentation fault (core dumped)
```

Let's try to run it with an argument:
```
level0@RainFall:~$ ./level0 test
No !
```

Alright, so we need to find the right argument. Let's try to run it with **gdb**:
```
level0@RainFall:~$ gdb ./level0
(gdb) disass main
Dump of assembler code for function main:
[...]
   0x08048ed9 <+25>:    cmp    $0x1a7,%eax
   0x08048ede <+30>:    jne    0x8048f58 <main+152>
[...]
   0x08048f4a <+138>:   movl   $0x80c5348,(%esp)
   0x08048f51 <+145>:   call   0x8054640 <execv>
[...]
   0x08048f78 <+184>:   mov    %eax,(%esp)
   0x08048f7b <+187>:   call   0x804a230 <fwrite>
   0x08048f80 <+192>:   mov    $0x0,%eax
   0x08048f85 <+197>:   leave
   0x08048f86 <+198>:   ret
```

Interesting, so we need to pass an argument that will make the _cmp_ instruction return 0 and execute the _execv_ instruction which uses the _0x80c5348_ address as an argument (which is "/bin/sh") otherwise it will simply output "No !\n". Let's try to pass 0x1a7 aka 423 as an argument:
```
level0@RainFall:~$ ./level0 423
$ whoami
level1
```

And we're in ! Let's get the flag:
```
$ cat /home/user/level1/.pass
1fe8a524fa4bec01ca4ea2a869af2a02260d4a7d5fe7e7c24d8617e6dca12d3a
```
